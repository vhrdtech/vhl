file = { SOI ~ file_item* ~ EOI }
file_item = _{ definition | inner_attribute }

// Number traits
/// 1, 2, 3, 4, 5, ...
natural_number = @{ '1'..'9' ~ ASCII_DIGIT* }
/// 0, 1, 2, 3, 4, 5, ...
whole_number = @{ ASCII_DIGIT+ }
/// ..., -3, -2, -1, 0, 1, 2, 3, ...
integer_number = @{ ("-" ~ natural_number) | whole_number }

/// Identifier, very permissive to allow parse stage to pass and show user friendly warning/error later in lint phase.
identifier = @{ XID_START ~ XID_CONTINUE* }

// Boolean
bool_ty = { "bool" }

// Discrete number types
/// i8 / i16 / i32 / i3 / i{expr}
discrete_signed_ty = @{ "i" ~ (natural_number | expression_braced) }
/// u8 / u16 / u32 / u11 / u{expr}
discrete_unsigned_ty = @{ "u" ~ (natural_number | expression_braced) }
discrete_any_ty = { (discrete_signed_ty | discrete_unsigned_ty) ~ si_expr_ticked? }

// Fixed point number types
/// Signed: q3.12 / q{ expr -> (m, n) } / q{ expr -> (m, discrete_any_ty) }
fixed_signed_ty = @{ "q" ~ (whole_number ~ "." ~ whole_number | expression_braced) }
/// Unsigned: uq1.15 / uq{ expr -> (m, n) }
fixed_unsigned_ty = @{ "uq" ~ (whole_number ~ "." ~ whole_number | expression_braced) }
fixed_any_ty = { (fixed_signed_ty | fixed_unsigned_ty) ~ si_expr_ticked? }

num_bound = { "unbound" | "max" ~ dec_lit | expression_list }

/// Floating point number types
floating_any_ty = { ("f32" | "f64") ~ si_expr_ticked? }

/// Textual types
textual_any_ty = { "char" | "str" }

// Sequence types
/// Unit: ()
unit_ty = { "(" ~ ")" }
/// Tuple: (t1, t2, ...)
tuple_fields = { any_ty ~ ("," ~ any_ty)* ~ ","? }
tuple_ty = { "(" ~ tuple_fields ~ ")" }
/// Array
array_ty = { "[" ~ any_ty ~ ";" ~ num_bound ~ "]" }

derive = { "_" }
type_param = _{ any_ty | expression}
generic_ty = { identifier ~ ("<" ~ type_param ~ ("," ~ type_param)* ~ ","? ~ ">") }

fn_declaration_params = { "()" }
fn_ty = { "fn" ~ fn_declaration_params ~ ("->" ~ any_ty)? }

/// Any supported type without access modifier
any_ty = _{ bool_ty | discrete_any_ty | fixed_any_ty | floating_any_ty | textual_any_ty | tuple_ty | array_ty | generic_ty | derive | fn_ty | identifier }

/// Access modifier
access_mod = { "const" | "rw" | "ro" | "wo" }

// Definitions
/// Alias type
type_alias_def = { doc_attr ~ "type" ~ identifier ~ "=" ~ any_ty ~ ";" }
/// Struct type
struct_field = { outer_attribute* ~ identifier ~ ":" ~ any_ty }
struct_fields = _{ struct_field ~ ("," ~ struct_field)* ~ ","? }
struct_def = {  "struct" ~ identifier ~ ("{" ~ struct_fields ~ "}" | ";") }
/// Tuple struct
tuple_struct_def = { "struct" ~ identifier ~ "(" ~ tuple_fields ~ ")" ~ ";" }
/// Enum
enum_item_tuple = { "(" ~ tuple_fields? ~ ")" }
enum_item_struct = { "{" ~ struct_fields ~ "}" }
enum_item_discriminant = { "=" ~ expression }
enum_item_kind = { enum_item_tuple | enum_item_struct | enum_item_discriminant }
enum_item = { doc_attr ~ identifier ~ enum_item_kind? }
enum_items = _{ enum_item ~ ("," ~ enum_item)* ~ ","? }
enum_def = { doc_attr ~ "enum" ~ identifier ~ "{" ~ enum_items? ~ "}" }
/// Function
def_fn = { doc_attr ~ "fn" ~ identifier ~ generics? ~ fn_args ~ fn_ret_ty? ~ "{" ~ statement* ~ "}" }
named_ty = { identifier ~ ":" ~ any_ty }
named_ty_list = { named_ty? ~ ("," ~ named_ty)* ~ ","? }
fn_args = { "(" ~ named_ty_list ~ ")" }
fn_ret_ty = { "->" ~ any_ty }
generics = { "<" ~ "T" ~ ">" }

definition = { type_alias_def | struct_def | tuple_struct_def | enum_def | def_fn | xpi_block }

// Statements
let_stmt = { "let" ~ identifier ~ (":" ~ any_ty)? ~ "=" ~ expression }
expr_stmt = { (expression | expression_braced) ~ ";"? }
statement = { let_stmt | expr_stmt }

// Literals
bool_lit = { "true" | "false" }
/// -10, 17, 0, +3, 127u16, 1_000, 1023_u32
dec_lit = @{ ASCII_DIGIT ~ (ASCII_DIGIT | "_")* ~ discrete_any_ty? }
dec_lit_raw = @{ ASCII_DIGIT ~ (ASCII_DIGIT | "_")* }
/// 0xAA, 0xcc, 0xff_u8
hex_lit = @{ "0x" ~ ASCII_HEX_DIGIT ~ (ASCII_HEX_DIGIT | "_")* ~ discrete_any_ty? }
/// 0b1111_0000, 0b101_u3
bin_lit = @{ "0b" ~ ASCII_BIN_DIGIT ~ (ASCII_BIN_DIGIT | "_")* ~ discrete_any_ty? }
/// 0o7
oct_lit = @{ "0o" ~ ASCII_OCT_DIGIT ~ (ASCII_OCT_DIGIT | "_")* ~ discrete_any_ty? }
/// Floating point
float_exponent = @{ "e" | "E" ~ dec_lit_raw }
float_lit = @{ (dec_lit_raw ~ float_exponent | dec_lit_raw ~ "." ~ dec_lit_raw ~ float_exponent?) ~ floating_any_ty? }
/// Any discrete literal followed by optional type
discrete_lit = _{ dec_lit | hex_lit | bin_lit | oct_lit }
/// Char literal 'a', '\u{7FFF}', '\n' '\t' '\r' '\\' '\0', '\x55'
char = _{
    !("\"" | "\\") ~ ANY
    | "\\" ~ ("\"" | "'" | "\\" | "/" | "b" | "f" | "n" | "r" | "t" | "0")
    | "\\" ~ ("u{" ~ ASCII_HEX_DIGIT{4, 6} ~ "}")
}
char_lit = { "'" ~ char ~ "'" }
/// String
string_lit = ${ "\"" ~ string_inner ~ "\"" }
string_inner = @{ char* }
/// Tuple literal
// tuple_lit = { "(" ~ any_lit ~ ("," ~ any_lit)* ~ ","? ~ ")" }

/// All possible literals
tuple_lit = { "(" ~ any_lit ~ ("," ~ any_lit)* ~ ","? ~ ")" }
struct_lit = { "TODO" }
enum_lit = { "TODO" }
array_lit = { "TODO" }
any_lit = { bool_lit | float_lit | discrete_lit | char_lit | string_lit | tuple_lit | struct_lit | enum_lit | array_lit }

// Operators
op_not = { "!" } // Bitwise NOT or Boolean NOT
op_plus = { "+" } // Can be unary in shifted numbers
op_minus = { "-" } // Negation or binary minus
op_mul = { "*" }
op_div = { "/" }
op_rem = { "%" }
op_bool_and = { "&&" }
op_bit_and = { "&" }
op_bool_or = { "||" }
op_bit_or = { "|" }
op_xor = { "^" }
op_lsh = { "<<" }
op_rsh = { ">>" }
op_closed_range = { "..=" }
op_open_range = { ".." }
op_dot = { "." }

op_unary = { op_minus | op_plus | op_not }
op_binary = { op_plus | op_minus | op_mul | op_div | op_rem | op_bool_and | op_bit_and | op_bool_or |
              op_bit_or | op_xor | op_lsh | op_rsh | op_closed_range | op_open_range | op_dot }

// Expressions
unary_expr = { op_unary ~ expression }

call_expr = { call_then_index | call_after_index | call_local }
call_then_index = _{ identifier ~ call_arguments ~ index_arguments }
call_after_index = _{ identifier ~ index_arguments ~ call_arguments }
call_local = _{ identifier ~ call_arguments }
index_into_expr = { identifier ~ index_arguments }
// call_method = _{ callable ~ ("." ~ identifier ~ call_arguments)+ }
// callable = _{ expression_braced | identifier | call_local }

infix_expr = _{ expression_inner ~ (op_binary ~ expression_inner)+ }
tuple_of_expressions = { "(" ~ expression ~ ("," ~ expression)+ ~ ","? ~ ")" }
call_arguments = { "(" ~ expression_list? ~ ")" }
index_arguments = { "[" ~ expression_list? ~ "]" }
resource_path_start = { "#.." | "#." | "#" }

expression_inner = _{ call_expr | index_into_expr | unary_expr | any_lit | tuple_of_expressions | identifier | resource_path_start | expression_parenthesized }
expression = { infix_expr | expression_inner }

// block_open = { "(" | "{" | "[" }
// block_close = { ")" | "}" | "]" }
// expression_block = { block_open ~ expression ~ block_close }
expression_braced = !{ "{" ~ expression ~ "}" }
expression_ticked = !{ "`" ~ expression ~ "`" }
expression_parenthesized = { "(" ~ expression ~ ")" }
expression_list = _{ expression ~ ("," ~ expression)* ~ ","? }

// Attributes
inner_attribute = { "#![" ~ attribute ~ "]" }
outer_attribute = { "#[" ~ attribute ~ "]" }
attribute = _{ simple_path ~ attribute_input? }
path_segment = { identifier }
simple_path = { "::"? ~ path_segment ~ ("::" ~ path_segment)* }
attribute_input = { delim_token_tree | "=" ~ expression }

// Optional doc comments and attributes prior to many user defined things
doc_attr = _{ doc_comment* ~ outer_attribute* }

// Keywords
kw_fn = { "fn" }
kw_let = { "let" }
kw_struct = { "struct" }
kw_type = { "type" }
kw_use = { "use" }
keyword = { kw_fn | kw_let | kw_struct | kw_type | kw_use }

// Punctuation
punct_plus = { "+" }
punct_minus = { "-" }
punct_star = { "*" }
punct_slash = { "/" }
punct_caret = { "^" }
punct_not = { "!" }
punctuation = { punct_plus | punct_minus | punct_star | punct_slash | punct_caret | punct_not }

// Delimiters
delimiter = { "{" | "}" | "[" | "]" | "(" | ")" }

// Tokens
token_tree = _{ token_except_delimiters | delim_token_tree }
delim_token_tree = { "(" ~ token_tree* ~ ")" | "[" ~ token_tree* ~ "]" | "{" ~ token_tree* ~ "}" }
token_except_delimiters = _{ keyword | identifier | any_lit | punctuation }
token = _{ token_except_delimiters | delimiter }

// xPI Blocks
xpi_block = { "/" ~ xpi_uri_segment ~ xpi_resource_ty? ~ xpi_body }
xpi_uri_segment = ${ (identifier ~ expression_ticked? ~ identifier?) | expression_ticked ~ identifier? }
xpi_resource_ty = { "<" ~ (access_mod? ~ any_ty)? ~ ("," ~ xpi_serial)? ~ ">" }
xpi_serial = @{ "'" ~ dec_lit_raw }
xpi_body = { "{" ~ xpi_field* ~ xpi_block* ~ "}" }
xpi_field = { identifier ~ ":" ~ expression ~ ";" }

// SI units
si_expr = { si_infix_expr | si_expr_inner }
si_expr_ticked = _{ "`" ~ si_expr ~ "`" }
si_expr_inner = _{ si_call_expr | si_name | dec_lit | float_lit }
si_infix_expr = _{ si_expr_inner ~ (si_op ~ si_expr_inner)+ }
si_name = @{ &("m" ~ !si_char) ~ si_char+ | &("T" ~ !si_char) ~ si_char+ | (bin_prefix | si_prefix)? ~ si_char+ }
si_prefix = ${
    "y" | "z" | "a" | "f" | "p" | "n" | "u" | "μ" | "m" | "c" | "da" |
    "d" | "h" | "k" | "M" | "G" | "T" | "P" | "E" | "Z" | "Y"
}
bin_prefix = ${ "Ki" | "Mi" | "Gi" | "Ti" | "Pi" | "Ei" | "Zi" | "Yi" }
si_char = _{ "Ω" | "°" | ASCII_ALPHA }
si_op = { "*" | "⋅" | "/" | "-" | "+" }
si_fn = { "unit_of" }
si_call_expr = _{ si_fn ~ call_arguments }

//
doc_comment = @{ "///" ~ (!NEWLINE ~ ANY)* ~ NEWLINE }
single_line_comment = { !"///" ~ "//" ~ (!NEWLINE ~ ANY)* ~ NEWLINE }
multi_line_comment = { "/*" ~ (!"*/" ~ ANY)* ~ "*/" }
COMMENT = _{ single_line_comment | multi_line_comment }
WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
